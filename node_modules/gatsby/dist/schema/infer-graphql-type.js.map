{"version":3,"sources":["../../src/schema/infer-graphql-type.js"],"names":["findLinkedNode","inferObjectStructureFromNodes","require","GraphQLObjectType","GraphQLBoolean","GraphQLString","GraphQLFloat","GraphQLInt","GraphQLList","GraphQLUnionType","_","invariant","oneLine","store","getNode","getNodes","createPageDependency","createTypeName","createKey","extractFieldExamples","isEmptyObjectOrArray","DateType","FileType","inferGraphQLType","exampleValue","selector","nodes","types","otherArgs","fieldName","split","pop","shouldInfer","isArray","getListType","getType","Array","inferredType","type","args","resolve","listType","object","context","resolveInfo","fieldValue","map","value","name","fields","isInteger","inferFromMapping","mapping","fieldSelector","matchedTypes","filter","isEmpty","console","log","findNode","path","linkedType","linkedNode","find","n","internal","id","nodeId","nodeObjectType","node","a","b","linkedField","inferFromFieldName","uniqBy","v","key","validateLinkedNode","validateField","field","findNodeType","linkedNodes","forEach","i","length","f","sort","join","description","resolveType","data","result","EXCLUDE_KEYS","parent","children","config","getState","isRoot","inferredFields","each","nextSelector","inferredField","includes","Object","keys"],"mappings":"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","file":"infer-graphql-type.js","sourcesContent":["// @flow\nconst {\n  GraphQLObjectType,\n  GraphQLBoolean,\n  GraphQLString,\n  GraphQLFloat,\n  GraphQLInt,\n  GraphQLList,\n  GraphQLUnionType,\n} = require(`graphql`)\nconst _ = require(`lodash`)\nconst invariant = require(`invariant`)\nconst { oneLine } = require(`common-tags`)\n\nconst { store, getNode, getNodes } = require(`../redux`)\nconst { createPageDependency } = require(`../redux/actions/add-page-dependency`)\nconst createTypeName = require(`./create-type-name`)\nconst createKey = require(`./create-key`)\nconst {\n  extractFieldExamples,\n  isEmptyObjectOrArray,\n} = require(`./data-tree-utils`)\nconst DateType = require(`./types/type-date`)\nconst FileType = require(`./types/type-file`)\n\nimport type { GraphQLOutputType } from \"graphql\"\nimport type {\n  GraphQLFieldConfig,\n  GraphQLFieldConfigMap,\n} from \"graphql/type/definition\"\n\nexport type ProcessedNodeType = {\n  name: string,\n  nodes: any[],\n  node: GraphQLFieldConfig<*, *>,\n  fieldsFromPlugins: any,\n  nodeObjectType: GraphQLOutputType,\n}\n\nfunction inferGraphQLType({\n  exampleValue,\n  selector,\n  nodes,\n  types,\n  ...otherArgs\n}): ?GraphQLFieldConfig<*, *> {\n  if (exampleValue == null || isEmptyObjectOrArray(exampleValue)) return null\n  let fieldName = selector.split(`.`).pop()\n\n  // Check this before checking for array as FileType has\n  // builtin support for inferring array of files and inferred\n  // array type will have faster resolver than resolving array\n  // of files separately.\n  if (FileType.shouldInfer(nodes, selector, exampleValue)) {\n    return _.isArray(exampleValue) ? FileType.getListType() : FileType.getType()\n  }\n\n  if (Array.isArray(exampleValue)) {\n    exampleValue = exampleValue[0]\n\n    if (exampleValue == null) return null\n\n    let inferredType = inferGraphQLType({\n      ...otherArgs,\n      exampleValue,\n      selector,\n      nodes,\n      types,\n    })\n    invariant(\n      inferredType,\n      `Could not infer graphQL type for value: ${exampleValue}`\n    )\n\n    const { type, args = null, resolve = null } = inferredType\n\n    const listType = { type: new GraphQLList(type), args }\n\n    if (resolve) {\n      // If inferredType has resolve function wrap it with Array.map\n      listType.resolve = (object, args, context, resolveInfo) => {\n        const fieldValue = object[fieldName]\n        if (!fieldValue) {\n          return null\n        }\n\n        // Field resolver expects first parameter to be plain object\n        // containing key with name of field we want to resolve.\n        return fieldValue.map(value =>\n          resolve({ [fieldName]: value }, args, context, resolveInfo)\n        )\n      }\n    }\n\n    return listType\n  }\n\n  if (DateType.shouldInfer(exampleValue)) {\n    return DateType.getType()\n  }\n\n  switch (typeof exampleValue) {\n    case `boolean`:\n      return { type: GraphQLBoolean }\n    case `string`:\n      return { type: GraphQLString }\n    case `object`:\n      return {\n        type: new GraphQLObjectType({\n          name: createTypeName(fieldName),\n          fields: inferObjectStructureFromNodes({\n            ...otherArgs,\n            exampleValue,\n            selector,\n            nodes,\n            types,\n          }),\n        }),\n      }\n    case `number`:\n      return _.isInteger(exampleValue)\n        ? { type: GraphQLInt }\n        : { type: GraphQLFloat }\n    default:\n      return null\n  }\n}\n\nfunction inferFromMapping(\n  value,\n  mapping,\n  fieldSelector,\n  types\n): ?GraphQLFieldConfig<*, *> {\n  const matchedTypes = types.filter(\n    type => type.name === mapping[fieldSelector]\n  )\n  if (_.isEmpty(matchedTypes)) {\n    console.log(`Couldn't find a matching node type for \"${fieldSelector}\"`)\n    return null\n  }\n\n  const findNode = (fieldValue, path) => {\n    const linkedType = mapping[fieldSelector]\n    const linkedNode = _.find(\n      getNodes(),\n      n => n.internal.type === linkedType && n.id === fieldValue\n    )\n    if (linkedNode) {\n      createPageDependency({ path, nodeId: linkedNode.id })\n      return linkedNode\n    }\n    return null\n  }\n\n  if (_.isArray(value)) {\n    return {\n      type: new GraphQLList(matchedTypes[0].nodeObjectType),\n      resolve: (node, a, b, { fieldName }) => {\n        const fieldValue = node[fieldName]\n\n        if (fieldValue) {\n          return fieldValue.map(value => findNode(value, b.path))\n        } else {\n          return null\n        }\n      },\n    }\n  }\n\n  return {\n    type: matchedTypes[0].nodeObjectType,\n    resolve: (node, a, b, { fieldName }) => {\n      const fieldValue = node[fieldName]\n\n      if (fieldValue) {\n        return findNode(fieldValue, b.path)\n      } else {\n        return null\n      }\n    },\n  }\n}\n\nexport function findLinkedNode(value, linkedField, path) {\n  let linkedNode\n  // If the field doesn't link to the id, use that for searching.\n  if (linkedField) {\n    linkedNode = getNodes().find(n => n[linkedField] === value)\n    // Else the field is linking to the node's id, the default.\n  } else {\n    linkedNode = getNode(value)\n  }\n\n  if (linkedNode) {\n    if (path) createPageDependency({ path, nodeId: linkedNode.id })\n    return linkedNode\n  }\n  return null\n}\n\nfunction inferFromFieldName(value, selector, types): GraphQLFieldConfig<*, *> {\n  let isArray = false\n  if (_.isArray(value)) {\n    isArray = true\n    // Reduce values to nodes with unique types.\n    value = _.uniqBy(value, v => getNode(v).internal.type)\n  }\n\n  const key = selector.split(`.`).pop()\n  const [, , linkedField] = key.split(`___`)\n\n  const validateLinkedNode = linkedNode => {\n    invariant(\n      linkedNode,\n      oneLine`\n        Encountered an error trying to infer a GraphQL type for: \"${selector}\".\n        There is no corresponding node with the ${linkedField || `id`}\n        field matching: \"${value}\"\n      `\n    )\n  }\n  const validateField = (linkedNode, field) => {\n    invariant(\n      field,\n      oneLine`\n        Encountered an error trying to infer a GraphQL type for: \"${selector}\".\n        There is no corresponding GraphQL type \"${\n          linkedNode.internal.type\n        }\" available\n        to link to this node.\n      `\n    )\n  }\n\n  const findNodeType = node =>\n    types.find(type => type.name === node.internal.type)\n\n  if (isArray) {\n    const linkedNodes = value.map(v => findLinkedNode(v))\n    linkedNodes.forEach(node => validateLinkedNode(node))\n    const fields = linkedNodes.map(node => findNodeType(node))\n    fields.forEach((field, i) => validateField(linkedNodes[i], field))\n\n    let type\n    // If there's more than one type, we'll create a union type.\n    if (fields.length > 1) {\n      type = new GraphQLUnionType({\n        name: `Union_${key}_${fields.map(f => f.name).sort().join(`__`)}`,\n        description: `Union interface for the field \"${key}\" for types [${fields\n          .map(f => f.name)\n          .sort()\n          .join(`, `)}]`,\n        types: fields.map(f => f.nodeObjectType),\n        resolveType: data =>\n          fields.find(f => f.name == data.internal.type).nodeObjectType,\n      })\n    } else {\n      type = fields[0].nodeObjectType\n    }\n\n    return {\n      type: new GraphQLList(type),\n      resolve: (node, a, b = {}) => {\n        let fieldValue = node[key]\n        if (fieldValue) {\n          return fieldValue.map(value =>\n            findLinkedNode(value, linkedField, b.path)\n          )\n        } else {\n          return null\n        }\n      },\n    }\n  }\n\n  const linkedNode = findLinkedNode(value, linkedField)\n  validateLinkedNode(linkedNode)\n  const field = findNodeType(linkedNode)\n  validateField(linkedNode, field)\n  return {\n    type: field.nodeObjectType,\n    resolve: (node, a, b = {}) => {\n      let fieldValue = node[key]\n      if (fieldValue) {\n        const result = findLinkedNode(fieldValue, linkedField, b.path)\n        return result\n      } else {\n        return null\n      }\n    },\n  }\n}\n\ntype inferTypeOptions = {\n  nodes: Object[],\n  types: ProcessedNodeType[],\n  selector?: string,\n  exampleValue?: Object,\n}\n\nconst EXCLUDE_KEYS = {\n  id: 1,\n  parent: 1,\n  children: 1,\n}\n\n// Call this for the top level node + recursively for each sub-object.\n// E.g. This gets called for Markdown and then for its frontmatter subobject.\nexport function inferObjectStructureFromNodes({\n  nodes,\n  types,\n  selector,\n  exampleValue = extractFieldExamples(nodes),\n}: inferTypeOptions): GraphQLFieldConfigMap<*, *> {\n  const config = store.getState().config\n  const isRoot = !selector\n  const mapping = config && config.mapping\n\n  // Ensure nodes have internal key with object.\n  nodes = nodes.map(n => (n.internal ? n : { ...n, internal: {} }))\n\n  const inferredFields = {}\n  _.each(exampleValue, (value, key) => {\n    // Remove fields common to the top-level of all nodes.  We add these\n    // elsewhere so don't need to infer their type.\n    if (isRoot && EXCLUDE_KEYS[key]) return\n\n    // Several checks to see if a field is pointing to custom type\n    // before we try automatic inference.\n    const nextSelector = selector ? `${selector}.${key}` : key\n    const fieldSelector = `${nodes[0].internal.type}.${nextSelector}`\n\n    let fieldName = key\n    let inferredField\n\n    // First check for manual field => type mappings in the site's\n    // gatsby-config.js\n    if (mapping && _.includes(Object.keys(mapping), fieldSelector)) {\n      inferredField = inferFromMapping(value, mapping, fieldSelector, types)\n\n      // Second if the field has a suffix of ___node. We use then the value\n      // (a node id) to find the node and use that node's type as the field\n    } else if (_.includes(key, `___NODE`)) {\n      ;[fieldName] = key.split(`___`)\n      inferredField = inferFromFieldName(value, nextSelector, types)\n    }\n\n    // Finally our automatic inference of field value type.\n    if (!inferredField) {\n      inferredField = inferGraphQLType({\n        nodes,\n        types,\n        exampleValue: value,\n        selector: nextSelector,\n      })\n    }\n\n    if (!inferredField) return\n\n    // Replace unsupported values\n    inferredFields[createKey(fieldName)] = inferredField\n  })\n\n  return inferredFields\n}\n"]}